use rand::Rng;

// This was generated by Claude Code for a quick experiment in simulated annealing acceptance

use crate::solver::{
    accepted_solution::AcceptedSolution, score::Score, solution::working_solution::WorkingSolution,
};

use super::accept_solution::{AcceptSolution, AcceptSolutionContext};

/// Simulated Annealing acceptor based on Ropke and Pisinger (2006).
///
/// The acceptor uses an exponential cooling schedule where temperature decreases
/// geometrically: T(i+1) = T(i) * cooling_rate
///
/// A candidate solution with score `s` is accepted if:
/// - It improves the best known solution, OR
/// - With probability exp(-delta / T), where delta = s - best_score
///
/// Parameters:
/// - `start_temperature`: Initial temperature T_0
/// - `end_temperature`: Final temperature T_end (used to compute cooling rate)
/// - `cooling_rate`: Geometric cooling factor (computed from start/end temps if not provided)
pub struct SimulatedAnnealingAcceptor {
    start_temperature: f64,
    cooling_rate: f64,
}

impl SimulatedAnnealingAcceptor {
    /// Creates a new SimulatedAnnealingAcceptor with explicit cooling rate.
    ///
    /// # Arguments
    /// * `start_temperature` - Initial temperature
    /// * `cooling_rate` - Temperature multiplier per iteration (typically 0.99-0.9999)
    pub fn new(start_temperature: f64, cooling_rate: f64) -> Self {
        Self {
            start_temperature,
            cooling_rate,
        }
    }

    /// Creates a SimulatedAnnealingAcceptor that reaches `end_temperature` after `max_iterations`.
    ///
    /// Computes cooling_rate = (end_temperature / start_temperature)^(1/max_iterations)
    ///
    /// # Arguments
    /// * `start_temperature` - Initial temperature
    /// * `end_temperature` - Target temperature at the end
    /// * `max_iterations` - Number of iterations to reach end temperature
    pub fn with_end_temperature(
        start_temperature: f64,
        end_temperature: f64,
        max_iterations: usize,
    ) -> Self {
        let cooling_rate = (end_temperature / start_temperature).powf(1.0 / max_iterations as f64);
        Self {
            start_temperature,
            cooling_rate,
        }
    }

    /// Computes the current temperature at the given iteration.
    /// T(i) = T_0 * cooling_rate^i
    fn compute_temperature(&self, iteration: usize) -> f64 {
        self.start_temperature * self.cooling_rate.powi(iteration as i32)
    }

    /// Computes the acceptance probability for a worse solution.
    /// P = exp(-delta / T) where delta > 0 represents the worsening in score.
    fn acceptance_probability(&self, delta: f64, temperature: f64) -> f64 {
        if temperature <= 0.0 {
            return 0.0;
        }
        (-delta / temperature).exp()
    }
}

impl AcceptSolution for SimulatedAnnealingAcceptor {
    fn accept(
        &self,
        current_solutions: &[AcceptedSolution],
        _solution: &WorkingSolution,
        score: &Score,
        context: AcceptSolutionContext,
    ) -> bool {
        // Always accept if we haven't filled the solution pool yet
        if current_solutions.len() < context.max_solutions {
            return true;
        }

        // Find the best (minimum) current solution
        let best_solution = current_solutions.iter().min_by_key(|s| s.score);

        let Some(best) = best_solution else {
            return true;
        };

        // Always accept improvements
        if score < &best.score {
            return true;
        }

        // For worse solutions, accept with probability based on temperature
        let temperature = self.compute_temperature(context.iteration);

        // Calculate how much worse the new solution is
        // We use soft_score as the primary measure for SA since hard constraints
        // are typically handled separately
        let delta = if score.hard_score > best.score.hard_score {
            // Hard constraint violation - use a large penalty
            score.hard_score - best.score.hard_score
        } else {
            score.soft_score - best.score.soft_score
        };

        if delta <= 0.0 {
            // This shouldn't happen given the check above, but handle it
            return true;
        }

        let probability = self.acceptance_probability(delta, temperature);
        let random_value: f64 = context.rng.random_range(0.0..=1.0);

        random_value < probability
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_compute_temperature() {
        let acceptor = SimulatedAnnealingAcceptor::new(100.0, 0.99);

        let t0 = acceptor.compute_temperature(0);
        assert!((t0 - 100.0).abs() < 1e-10);

        let t1 = acceptor.compute_temperature(1);
        assert!((t1 - 99.0).abs() < 1e-10);

        let t100 = acceptor.compute_temperature(100);
        assert!((t100 - 100.0 * 0.99_f64.powi(100)).abs() < 1e-10);
    }

    #[test]
    fn test_with_end_temperature() {
        let max_iterations = 10000;
        let acceptor =
            SimulatedAnnealingAcceptor::with_end_temperature(100.0, 0.01, max_iterations);

        let t_start = acceptor.compute_temperature(0);
        assert!((t_start - 100.0).abs() < 1e-10);

        let t_end = acceptor.compute_temperature(max_iterations);
        assert!((t_end - 0.01).abs() < 1e-6);
    }

    #[test]
    fn test_acceptance_probability() {
        let acceptor = SimulatedAnnealingAcceptor::new(100.0, 0.99);

        // At high temperature, probability should be relatively high
        let prob_high_temp = acceptor.acceptance_probability(10.0, 100.0);
        assert!(prob_high_temp > 0.9); // exp(-10/100) ≈ 0.905

        // At low temperature, probability should be very low for same delta
        let prob_low_temp = acceptor.acceptance_probability(10.0, 1.0);
        assert!(prob_low_temp < 0.001); // exp(-10/1) ≈ 0.000045

        // Zero delta should give probability 1
        let prob_zero = acceptor.acceptance_probability(0.0, 100.0);
        assert!((prob_zero - 1.0).abs() < 1e-10);

        // Zero temperature should give probability 0
        let prob_zero_temp = acceptor.acceptance_probability(10.0, 0.0);
        assert!((prob_zero_temp - 0.0).abs() < 1e-10);
    }
}
