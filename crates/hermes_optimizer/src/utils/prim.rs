/// This file was generated by Claude Code

pub struct MstResult {
    pub adjacency: Vec<Vec<usize>>,
    pub total_cost: f64,
}

/// Computes a minimum spanning tree using Prim's algorithm optimized for dense
/// (complete) graphs. Uses an array-based approach: O(n²) total, which is
/// optimal for complete graphs and avoids the O(n² log n) overhead of a
/// binary heap.
///
/// `cost_fn(from, to)` returns the edge cost between two nodes.
/// `exclude` optionally excludes a node from the MST (used for 1-tree construction).
///
/// Returns the adjacency list and total MST cost.
pub fn prim_mst(
    num_nodes: usize,
    cost_fn: impl Fn(usize, usize) -> f64,
    exclude: Option<usize>,
) -> MstResult {
    let mut adjacency: Vec<Vec<usize>> = vec![vec![]; num_nodes];

    let node_count = if exclude.is_some() {
        num_nodes - 1
    } else {
        num_nodes
    };

    if node_count <= 1 {
        return MstResult {
            adjacency,
            total_cost: 0.0,
        };
    }

    // Find the start node (first non-excluded node)
    let start = if exclude == Some(0) { 1 } else { 0 };

    // For each node, track the cheapest edge connecting it to the MST
    let mut min_cost = vec![f64::INFINITY; num_nodes];
    let mut min_from = vec![0usize; num_nodes];
    let mut in_mst = vec![false; num_nodes];
    if let Some(ex) = exclude {
        in_mst[ex] = true; // mark excluded as if already in MST
    }

    // Initialize with edges from start
    in_mst[start] = true;
    for j in 0..num_nodes {
        if !in_mst[j] {
            min_cost[j] = cost_fn(start, j);
            min_from[j] = start;
        }
    }

    let mut total_cost = 0.0;

    for _ in 0..(node_count - 1) {
        // Find the non-MST node with minimum cost edge to MST
        let mut best_node = usize::MAX;
        let mut best_cost = f64::INFINITY;

        for j in 0..num_nodes {
            if !in_mst[j] && min_cost[j] < best_cost {
                best_cost = min_cost[j];
                best_node = j;
            }
        }

        if best_node == usize::MAX {
            break; // disconnected graph (shouldn't happen for complete graphs)
        }

        // Add best_node to MST
        in_mst[best_node] = true;
        let from = min_from[best_node];
        adjacency[from].push(best_node);
        adjacency[best_node].push(from);
        total_cost += best_cost;

        // Update min_cost for remaining nodes
        for j in 0..num_nodes {
            if !in_mst[j] {
                let c = cost_fn(best_node, j);
                if c < min_cost[j] {
                    min_cost[j] = c;
                    min_from[j] = best_node;
                }
            }
        }
    }

    MstResult {
        adjacency,
        total_cost,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_prim_mst_triangle() {
        // Triangle: 0-1 cost 1, 0-2 cost 3, 1-2 cost 2
        // MST should pick edges 0-1 (cost 1) and 1-2 (cost 2), total cost 3
        let costs = [[0.0, 1.0, 3.0], [1.0, 0.0, 2.0], [3.0, 2.0, 0.0]];

        let result = prim_mst(3, |from, to| costs[from][to], None);

        assert!(!result.adjacency[0].is_empty());
        assert!(!result.adjacency[1].is_empty());
        assert!(!result.adjacency[2].is_empty());

        let total_edges: usize = result.adjacency.iter().map(|v| v.len()).sum();
        assert_eq!(total_edges, 4); // 2 edges × 2 directions

        assert!(result.adjacency[0].contains(&1));
        assert!(result.adjacency[1].contains(&0));
        assert!(result.adjacency[1].contains(&2));
        assert!(result.adjacency[2].contains(&1));
        assert!(!result.adjacency[0].contains(&2));

        assert!((result.total_cost - 3.0).abs() < 1e-9);
    }

    #[test]
    fn test_prim_mst_exclude_node() {
        // 4 nodes, exclude node 0. MST on nodes 1,2,3.
        // 1-2: 1, 2-3: 1, 1-3: 10
        let costs = [
            [0.0, 5.0, 5.0, 5.0],
            [5.0, 0.0, 1.0, 10.0],
            [5.0, 1.0, 0.0, 1.0],
            [5.0, 10.0, 1.0, 0.0],
        ];

        let result = prim_mst(4, |from, to| costs[from][to], Some(0));

        // Node 0 should have no neighbors
        assert!(result.adjacency[0].is_empty());
        // MST on {1,2,3}: edges 1-2 (cost 1) and 2-3 (cost 1)
        assert!((result.total_cost - 2.0).abs() < 1e-9);
    }

    #[test]
    fn test_prim_mst_single_node() {
        let result = prim_mst(1, |_, _| 1.0, None);
        assert_eq!(result.adjacency.len(), 1);
        assert!(result.adjacency[0].is_empty());
        assert!((result.total_cost).abs() < 1e-9);
    }

    #[test]
    fn test_prim_mst_two_nodes() {
        let result = prim_mst(2, |_, _| 5.0, None);
        assert_eq!(result.adjacency[0], vec![1]);
        assert_eq!(result.adjacency[1], vec![0]);
        assert!((result.total_cost - 5.0).abs() < 1e-9);
    }
}
