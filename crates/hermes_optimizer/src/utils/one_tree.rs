/// This file was generated by Claude Code
/// TODO: Manual review of the literature to make sure Claude generated the correct code.
/// 1) Florian Arnold, Michel Gendreau, Kenneth Sörensen, Efficiently solving very large-scale routing problems, Computers and Operations Research (2019), doi:https://doi.org/10.1016/j.cor.2019.03.006
/// 2) Michael Held, Richard M. Karp, (1970) The Traveling-Salesman Problem and Minimum Spanning Trees. Operations Research 18(6):1138-1162.https://doi.org/10.1287/opre.18.6.1138
/// 3) Held, M., Karp, R.M. The traveling-salesman problem and minimum spanning trees: Part II. Mathematical Programming 1, 6–25 (1971). https://doi.org/10.1007/BF01584070
use rayon::iter::{IntoParallelIterator, ParallelIterator};

use super::prim::prim_mst;

/// Computes alpha-nearness values for all edges using the 1-tree Held-Karp
/// lower bound with subgradient optimization.
///
/// Alpha-nearness of edge (i,j) = cost of the minimum 1-tree forced to contain
/// edge (i,j) minus the cost of the optimal 1-tree. Edges with small alpha
/// values are structurally important and likely to appear in good solutions.
///
/// `cost_fn(from, to)` returns the original edge cost.
/// Returns a flat matrix `alpha[i * num_nodes + j]` of alpha values.
pub fn compute_alpha_nearness(
    num_nodes: usize,
    cost_fn: impl Fn(usize, usize) -> f64 + Sync,
) -> Vec<f64> {
    if num_nodes <= 2 {
        return vec![0.0; num_nodes * num_nodes];
    }

    // The special node excluded from the MST (node 0, typically the depot)
    let special = 0;

    // Subgradient optimization to find optimal pi-values
    let pi = subgradient_optimization(num_nodes, &cost_fn, special);

    // Modified cost function: c'(i,j) = c(i,j) + pi[i] + pi[j]
    let modified_cost = |i: usize, j: usize| -> f64 { cost_fn(i, j) + pi[i] + pi[j] };

    // Build optimal 1-tree: MST on non-special nodes + two cheapest edges from special
    let mst_result = prim_mst(num_nodes, &modified_cost, Some(special));

    // Compute the beta values: for each pair (i,j) of non-special nodes,
    // beta(i,j) is the maximum edge cost on the unique MST path from i to j.
    // When we force a non-MST edge (i,j), we can remove the heaviest edge on
    // the MST path between i and j, so the cost increase is edge_cost - beta.
    let beta = compute_beta_values(num_nodes, &mst_result.adjacency, &modified_cost);

    // Find the two cheapest edges from the special node (used in the optimal 1-tree)
    let mut special_edges: Vec<(f64, usize)> = (0..num_nodes)
        .filter(|&n| n != special)
        .map(|n| (modified_cost(special, n), n))
        .collect();
    special_edges
        .sort_unstable_by(|a, b| a.0.partial_cmp(&b.0).unwrap_or(std::cmp::Ordering::Equal));

    let cheapest_1 = special_edges[0]; // (cost, node)
    let cheapest_2 = special_edges[1]; // (cost, node)

    // Compute alpha-nearness for every edge
    let mut alpha = vec![0.0_f64; num_nodes * num_nodes];

    for i in 0..num_nodes {
        for j in (i + 1)..num_nodes {
            let a = if i == special || j == special {
                // Edge involves the special node.
                let other = if i == special { j } else { i };
                let edge_cost = modified_cost(special, other);

                if other == cheapest_1.1 || other == cheapest_2.1 {
                    0.0
                } else {
                    (edge_cost - cheapest_2.0).max(0.0)
                }
            } else {
                // Edge does not involve the special node.
                let edge_cost = modified_cost(i, j);
                let b = beta[i * num_nodes + j];

                if b == f64::MAX {
                    f64::MAX
                } else {
                    (edge_cost - b).max(0.0)
                }
            };

            alpha[i * num_nodes + j] = a;
            alpha[j * num_nodes + i] = a;
        }
    }

    alpha
}

/// Returns the k-nearest neighbors for each node based on alpha-nearness.
/// `result[i]` contains the node indices sorted by ascending alpha value.
pub fn alpha_nearest_neighbors(
    num_nodes: usize,
    cost_fn: impl Fn(usize, usize) -> f64 + Sync,
    k: usize,
) -> Vec<Vec<usize>> {
    let alpha = compute_alpha_nearness(num_nodes, &cost_fn);
    let k = k.min(num_nodes - 1);

    (0..num_nodes)
        .map(|i| {
            let mut neighbors: Vec<(f64, usize)> = (0..num_nodes)
                .filter(|&j| j != i)
                .map(|j| (alpha[i * num_nodes + j], j))
                .collect();

            // Use partial sort: partition around k-th element in O(n),
            // then sort only the first k elements in O(k log k)
            if k < neighbors.len() {
                neighbors.select_nth_unstable_by(k, |a, b| {
                    a.0.partial_cmp(&b.0).unwrap_or(std::cmp::Ordering::Equal)
                });
                neighbors.truncate(k);
            }
            neighbors.sort_unstable_by(|a, b| {
                a.0.partial_cmp(&b.0).unwrap_or(std::cmp::Ordering::Equal)
            });

            neighbors.into_iter().map(|(_, j)| j).collect()
        })
        .collect()
}

/// Subgradient optimization to find pi-values that maximize the 1-tree lower bound.
fn subgradient_optimization(
    num_nodes: usize,
    cost_fn: &(impl Fn(usize, usize) -> f64 + Sync),
    special: usize,
) -> Vec<f64> {
    let max_iterations = if num_nodes > 1000 { 50 } else { 100 };
    let mut pi = vec![0.0; num_nodes];
    let mut best_lower_bound = f64::NEG_INFINITY;
    let mut best_pi = pi.clone();

    // Initial step size parameter
    let mut t = 1.0;
    let period = (num_nodes / 2).max(10).min(max_iterations);
    let mut no_improvement_count = 0;

    for iteration in 0..max_iterations {
        let modified_cost = |i: usize, j: usize| -> f64 { cost_fn(i, j) + pi[i] + pi[j] };

        // Compute 1-tree with current pi-values
        let (one_tree_cost, degree) = compute_1tree_with_degree(num_nodes, &modified_cost, special);

        // The lower bound is the 1-tree cost minus 2 * sum(pi), since each node
        // should have degree 2 in a tour
        let lower_bound = one_tree_cost - 2.0 * pi.iter().sum::<f64>();

        if lower_bound > best_lower_bound {
            best_lower_bound = lower_bound;
            best_pi = pi.clone();
            no_improvement_count = 0;
        } else {
            no_improvement_count += 1;
        }

        // Early termination if no improvement for a full period
        if no_improvement_count >= period {
            break;
        }

        // Check if we found a tour (all degrees == 2)
        let is_tour = degree.iter().all(|&d| d == 2);
        if is_tour {
            break;
        }

        // Subgradient: d[i] = degree[i] - 2 (target degree is 2 for a tour)
        let norm_sq: f64 = degree
            .iter()
            .map(|&d| {
                let g = d as f64 - 2.0;
                g * g
            })
            .sum();

        if norm_sq < 1e-10 {
            break;
        }

        // Update step size periodically
        if iteration > 0 && iteration % period == 0 {
            t *= 0.75;
        }

        // Update pi-values using subgradient ascent
        let step = t * best_lower_bound.abs().max(1.0) / norm_sq;
        for i in 0..num_nodes {
            pi[i] += step * (degree[i] as f64 - 2.0);
        }
    }

    best_pi
}

/// Computes the 1-tree cost and the degree of each node in the 1-tree.
fn compute_1tree_with_degree(
    num_nodes: usize,
    cost_fn: &impl Fn(usize, usize) -> f64,
    special: usize,
) -> (f64, Vec<usize>) {
    let mst = prim_mst(num_nodes, cost_fn, Some(special));
    let mut degree: Vec<usize> = mst.adjacency.iter().map(|adj| adj.len()).collect();

    // Find two cheapest edges from the special node
    let mut special_edges: Vec<(f64, usize)> = (0..num_nodes)
        .filter(|&n| n != special)
        .map(|n| (cost_fn(special, n), n))
        .collect();
    special_edges
        .sort_unstable_by(|a, b| a.0.partial_cmp(&b.0).unwrap_or(std::cmp::Ordering::Equal));

    let total_cost = mst.total_cost + special_edges[0].0 + special_edges[1].0;

    // Update degrees for the two special edges
    degree[special] = 2;
    degree[special_edges[0].1] += 1;
    degree[special_edges[1].1] += 1;

    (total_cost, degree)
}

/// Computes beta values using DFS on the MST, parallelized with rayon.
/// beta[i * n + j] = maximum edge cost on the unique MST path from i to j.
/// This is needed to compute alpha for non-MST edges.
fn compute_beta_values(
    num_nodes: usize,
    adjacency: &[Vec<usize>],
    cost_fn: &(impl Fn(usize, usize) -> f64 + Sync),
) -> Vec<f64> {
    // Each row is computed independently via DFS, so we parallelize across rows.
    let rows: Vec<Vec<f64>> = (0..num_nodes)
        .into_par_iter()
        .map(|start| {
            let mut row = vec![f64::MAX; num_nodes];
            row[start] = 0.0;

            let mut stack: Vec<(usize, f64)> = vec![(start, 0.0)];
            let mut visited = vec![false; num_nodes];
            visited[start] = true;

            while let Some((node, max_cost_on_path)) = stack.pop() {
                row[node] = max_cost_on_path;

                for &neighbor in &adjacency[node] {
                    if !visited[neighbor] {
                        visited[neighbor] = true;
                        let edge_cost = cost_fn(node, neighbor);
                        let new_max = max_cost_on_path.max(edge_cost);
                        stack.push((neighbor, new_max));
                    }
                }
            }

            row
        })
        .collect();

    // Flatten into the n² matrix
    let mut beta = vec![f64::MAX; num_nodes * num_nodes];
    for (i, row) in rows.into_iter().enumerate() {
        beta[i * num_nodes..(i + 1) * num_nodes].copy_from_slice(&row);
    }
    beta
}

#[cfg(test)]
mod tests {
    use super::*;

    /// With 3 nodes and only 3 possible edges, every edge must be in the 1-tree
    /// (MST on {1,2} = edge 1-2, plus edges 0-1 and 0-2 from special node).
    /// So all alpha values should be 0.
    #[test]
    fn test_alpha_nearness_triangle() {
        let costs = [[0.0, 1.0, 3.0], [1.0, 0.0, 2.0], [3.0, 2.0, 0.0]];
        let alpha = compute_alpha_nearness(3, |i, j| costs[i][j]);

        assert!(alpha[1] < 1e-6, "alpha(0,1) = {}", alpha[1]);
        assert!(alpha[2] < 1e-6, "alpha(0,2) = {}", alpha[2]);
        assert!(alpha[3 + 2] < 1e-6, "alpha(1,2) = {}", alpha[3 + 2]);
    }

    /// 5-node example with clear structure. Nodes on a line: 0-1-2-3-4
    /// with short sequential edges and expensive cross edges.
    /// Without pi-values (pi=0), manually verify:
    ///   Special = 0, MST on {1,2,3,4}: 1-2(1), 2-3(1), 3-4(1) cost=3
    ///   Two cheapest from 0: 0-1(1), 0-2(2) → 1-tree cost = 3+1+2 = 6
    ///   Edge 0-3(3): replaces 0-2(2), alpha = 3-2 = 1
    ///   Edge 0-4(4): replaces 0-2(2), alpha = 4-2 = 2
    ///   Edge 1-3(2): MST path 1→2→3, beta=max(1,1)=1, alpha=2-1=1
    ///   Edge 1-4(3): MST path 1→2→3→4, beta=max(1,1,1)=1, alpha=3-1=2
    ///   Edge 2-4(2): MST path 2→3→4, beta=max(1,1)=1, alpha=2-1=1
    ///   Edge 1-2(1): in MST, beta=1, alpha=1-1=0
    #[test]
    fn test_alpha_nearness_five_nodes_no_pi() {
        // Line graph costs: dist(i,j) = |i-j|
        let n = 5;
        let alpha = compute_alpha_nearness(n, |i, j| (i as f64 - j as f64).abs());

        // Edges in the optimal 1-tree should have alpha = 0 or very small
        // 0-1 is a special edge (cheapest from 0): alpha ≈ 0
        assert!(alpha[1] < 0.5, "alpha(0,1) = {}", alpha[1]);
        // 0-2 is a special edge (second cheapest from 0): alpha ≈ 0
        assert!(alpha[2] < 0.5, "alpha(0,2) = {}", alpha[2]);
        // 1-2, 2-3, 3-4 are MST edges: alpha ≈ 0
        assert!(alpha[n + 2] < 0.5, "alpha(1,2) = {}", alpha[n + 2]);
        assert!(alpha[2 * n + 3] < 0.5, "alpha(2,3) = {}", alpha[2 * n + 3]);
        assert!(alpha[3 * n + 4] < 0.5, "alpha(3,4) = {}", alpha[3 * n + 4]);

        // Cross edges should have higher alpha
        // 0-4 (cost 4) should have higher alpha than 0-1 (cost 1)
        assert!(
            alpha[4] > alpha[1],
            "alpha(0,4)={} should be > alpha(0,1)={}",
            alpha[4],
            alpha[1]
        );
        // 1-4 (cost 3) should have higher alpha than 1-2 (cost 1)
        assert!(
            alpha[n + 4] > alpha[n + 2],
            "alpha(1,4)={} should be > alpha(1,2)={}",
            alpha[n + 4],
            alpha[n + 2]
        );
    }

    /// Verify that alpha-nearest neighbors correctly orders by alpha value.
    #[test]
    fn test_alpha_nearest_neighbors_ordering() {
        // Square graph: tour edges cheap (1), diagonals expensive (10)
        let costs = [
            [0.0, 1.0, 10.0, 1.0],
            [1.0, 0.0, 1.0, 10.0],
            [10.0, 1.0, 0.0, 1.0],
            [1.0, 10.0, 1.0, 0.0],
        ];

        let neighbors = alpha_nearest_neighbors(4, |i, j| costs[i][j], 3);

        // Each node should have 3 neighbors (all others)
        for n in &neighbors {
            assert_eq!(n.len(), 3);
        }

        // Node 0's best neighbors should be 1 and 3 (cost 1 each), not 2 (cost 10)
        // So 2 should be last in the neighbor list
        assert_eq!(
            neighbors[0][2], 2,
            "Node 2 should be node 0's worst neighbor, got {:?}",
            neighbors[0]
        );
    }

    #[test]
    fn test_alpha_nearness_symmetric() {
        let costs = [
            [0.0, 1.0, 10.0, 1.0],
            [1.0, 0.0, 1.0, 10.0],
            [10.0, 1.0, 0.0, 1.0],
            [1.0, 10.0, 1.0, 0.0],
        ];
        let alpha = compute_alpha_nearness(4, |i, j| costs[i][j]);

        // Alpha should be symmetric
        for i in 0..4 {
            for j in 0..4 {
                assert!(
                    (alpha[i * 4 + j] - alpha[j * 4 + i]).abs() < 1e-9,
                    "alpha({},{})={} != alpha({},{})={}",
                    i,
                    j,
                    alpha[i * 4 + j],
                    j,
                    i,
                    alpha[j * 4 + i]
                );
            }
        }
    }

    #[test]
    fn test_alpha_nearness_two_nodes() {
        let alpha = compute_alpha_nearness(2, |_, _| 5.0);
        assert!((alpha[1]).abs() < 1e-6);
        assert!((alpha[2]).abs() < 1e-6);
    }
}
