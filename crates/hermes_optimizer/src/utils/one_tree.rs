/// This file was generated by Claude Code
/// TODO: Manual review of the literature to make sure Claude generated the correct code.
/// 1) Florian Arnold, Michel Gendreau, Kenneth Sörensen, Efficiently solving very large-scale routing problems, Computers and Operations Research (2019), doi:https://doi.org/10.1016/j.cor.2019.03.006
/// 2) Michael Held, Richard M. Karp, (1970) The Traveling-Salesman Problem and Minimum Spanning Trees. Operations Research 18(6):1138-1162.https://doi.org/10.1287/opre.18.6.1138
/// 3) Held, M., Karp, R.M. The traveling-salesman problem and minimum spanning trees: Part II. Mathematical Programming 1, 6–25 (1971). https://doi.org/10.1007/BF01584070
use rayon::iter::{IntoParallelIterator, ParallelIterator};

use super::prim::prim_mst;

/// Returns the k-nearest neighbors for each node based on alpha-nearness.
/// `result[i]` contains the node indices sorted by ascending alpha value.
///
/// Fuses alpha and beta computation to avoid allocating full n² matrices.
/// For each node, computes beta via DFS, derives alpha values, and extracts
/// the top-k neighbors — all with O(n) temporary memory per thread.
pub fn alpha_nearest_neighbors(
    num_nodes: usize,
    cost_fn: impl Fn(usize, usize) -> f64 + Sync,
    k: usize,
) -> Vec<Vec<usize>> {
    if num_nodes <= 2 {
        return (0..num_nodes)
            .map(|i| (0..num_nodes).filter(|&j| j != i).collect())
            .collect();
    }

    let k = k.min(num_nodes - 1);
    let special = 0;

    // Subgradient optimization to find optimal pi-values
    let pi = subgradient_optimization(num_nodes, &cost_fn, special);

    // Modified cost function: c'(i,j) = c(i,j) + pi[i] + pi[j]
    let modified_cost = |i: usize, j: usize| -> f64 { cost_fn(i, j) + pi[i] + pi[j] };

    // Build optimal 1-tree: MST on non-special nodes + two cheapest edges from special
    let mst_result = prim_mst(num_nodes, modified_cost, Some(special));

    // Find the two cheapest edges from the special node
    let (cheapest_1, cheapest_2) = two_cheapest_special_edges(num_nodes, &modified_cost, special);

    let adjacency = &mst_result.adjacency;

    // For each node, compute beta row via DFS, derive alpha, extract top-k
    (0..num_nodes)
        .into_par_iter()
        .map(|i| {
            // Step 1: Compute beta[i, *] via DFS on the MST
            let beta_row = compute_beta_row(num_nodes, adjacency, &modified_cost, i);

            // Step 2: Compute alpha[i, j] for all j != i
            let mut neighbors: Vec<(f64, usize)> = Vec::with_capacity(num_nodes - 1);

            for j in 0..num_nodes {
                if j == i {
                    continue;
                }

                let a = if i == special || j == special {
                    let other = if i == special { j } else { i };
                    let edge_cost = modified_cost(special, other);

                    if other == cheapest_1.1 || other == cheapest_2.1 {
                        0.0
                    } else {
                        (edge_cost - cheapest_2.0).max(0.0)
                    }
                } else {
                    let edge_cost = modified_cost(i, j);
                    let b = beta_row[j];

                    if b == f64::MAX {
                        f64::MAX
                    } else {
                        (edge_cost - b).max(0.0)
                    }
                };

                neighbors.push((a, j));
            }

            // Step 3: Extract top-k via partial sort
            if k < neighbors.len() {
                neighbors.select_nth_unstable_by(k, |a, b| {
                    a.0.partial_cmp(&b.0).unwrap_or(std::cmp::Ordering::Equal)
                });
                neighbors.truncate(k);
            }
            neighbors.sort_unstable_by(|a, b| {
                a.0.partial_cmp(&b.0).unwrap_or(std::cmp::Ordering::Equal)
            });

            neighbors.into_iter().map(|(_, j)| j).collect()
        })
        .collect()
}

/// Finds the two cheapest edges from the special node in O(n).
fn two_cheapest_special_edges(
    num_nodes: usize,
    cost_fn: &impl Fn(usize, usize) -> f64,
    special: usize,
) -> ((f64, usize), (f64, usize)) {
    let mut first = (f64::INFINITY, usize::MAX);
    let mut second = (f64::INFINITY, usize::MAX);

    for n in 0..num_nodes {
        if n == special {
            continue;
        }
        let cost = cost_fn(special, n);
        if cost < first.0 {
            second = first;
            first = (cost, n);
        } else if cost < second.0 {
            second = (cost, n);
        }
    }

    (first, second)
}

/// Subgradient optimization to find pi-values that maximize the 1-tree lower bound.
fn subgradient_optimization(
    num_nodes: usize,
    cost_fn: &(impl Fn(usize, usize) -> f64 + Sync),
    special: usize,
) -> Vec<f64> {
    let max_iterations = if num_nodes > 1000 { 50 } else { 100 };
    let mut pi = vec![0.0; num_nodes];
    let mut best_lower_bound = f64::NEG_INFINITY;
    let mut best_pi = pi.clone();

    // Initial step size parameter
    let mut t = 1.0;
    let period = (num_nodes / 2).max(10).min(max_iterations);
    let mut no_improvement_count = 0;

    for iteration in 0..max_iterations {
        let modified_cost = |i: usize, j: usize| -> f64 { cost_fn(i, j) + pi[i] + pi[j] };

        // Compute 1-tree with current pi-values
        let (one_tree_cost, degree) = compute_1tree_with_degree(num_nodes, &modified_cost, special);

        // The lower bound is the 1-tree cost minus 2 * sum(pi), since each node
        // should have degree 2 in a tour
        let lower_bound = one_tree_cost - 2.0 * pi.iter().sum::<f64>();

        if lower_bound > best_lower_bound {
            best_lower_bound = lower_bound;
            best_pi = pi.clone();
            no_improvement_count = 0;
        } else {
            no_improvement_count += 1;
        }

        // Early termination if no improvement for a full period
        if no_improvement_count >= period {
            break;
        }

        // Check if we found a tour (all degrees == 2)
        let is_tour = degree.iter().all(|&d| d == 2);
        if is_tour {
            break;
        }

        // Subgradient: d[i] = degree[i] - 2 (target degree is 2 for a tour)
        let norm_sq: f64 = degree
            .iter()
            .map(|&d| {
                let g = d as f64 - 2.0;
                g * g
            })
            .sum();

        if norm_sq < 1e-10 {
            break;
        }

        // Update step size periodically
        if iteration > 0 && iteration % period == 0 {
            t *= 0.75;
        }

        // Update pi-values using subgradient ascent
        let step = t * best_lower_bound.abs().max(1.0) / norm_sq;
        for i in 0..num_nodes {
            pi[i] += step * (degree[i] as f64 - 2.0);
        }
    }

    best_pi
}

/// Computes the 1-tree cost and the degree of each node in the 1-tree.
fn compute_1tree_with_degree(
    num_nodes: usize,
    cost_fn: &impl Fn(usize, usize) -> f64,
    special: usize,
) -> (f64, Vec<usize>) {
    let mst = prim_mst(num_nodes, cost_fn, Some(special));
    let mut degree: Vec<usize> = mst.adjacency.iter().map(|adj| adj.len()).collect();

    let (cheapest_1, cheapest_2) = two_cheapest_special_edges(num_nodes, cost_fn, special);

    let total_cost = mst.total_cost + cheapest_1.0 + cheapest_2.0;

    // Update degrees for the two special edges
    degree[special] = 2;
    degree[cheapest_1.1] += 1;
    degree[cheapest_2.1] += 1;

    (total_cost, degree)
}

/// Computes beta values for a single source node via DFS on the MST.
/// Returns a Vec where `result[j]` = maximum edge cost on the unique MST path
/// from `start` to `j`.
fn compute_beta_row(
    num_nodes: usize,
    adjacency: &[Vec<usize>],
    cost_fn: &impl Fn(usize, usize) -> f64,
    start: usize,
) -> Vec<f64> {
    let mut row = vec![f64::MAX; num_nodes];
    row[start] = 0.0;

    let mut stack: Vec<(usize, f64)> = vec![(start, 0.0)];
    let mut visited = vec![false; num_nodes];
    visited[start] = true;

    while let Some((node, max_cost_on_path)) = stack.pop() {
        row[node] = max_cost_on_path;

        for &neighbor in &adjacency[node] {
            if !visited[neighbor] {
                visited[neighbor] = true;
                let edge_cost = cost_fn(node, neighbor);
                let new_max = max_cost_on_path.max(edge_cost);
                stack.push((neighbor, new_max));
            }
        }
    }

    row
}

#[cfg(test)]
mod tests {
    use super::*;

    /// With 3 nodes, every node must be a neighbor of every other node.
    /// All edges are structurally required so the best neighbors should
    /// include all other nodes.
    #[test]
    fn test_alpha_nearest_triangle() {
        let costs = [[0.0, 1.0, 3.0], [1.0, 0.0, 2.0], [3.0, 2.0, 0.0]];
        let neighbors = alpha_nearest_neighbors(3, |i, j| costs[i][j], 2);

        for i in 0..3 {
            assert_eq!(neighbors[i].len(), 2);
        }
    }

    /// 5-node line graph: 0-1-2-3-4 with dist(i,j) = |i-j|.
    /// Adjacent nodes (small alpha) should appear before distant nodes.
    #[test]
    fn test_alpha_nearest_five_nodes_line() {
        let neighbors = alpha_nearest_neighbors(5, |i, j| (i as f64 - j as f64).abs(), 2);

        // Node 0's two nearest by alpha should be 1 and 2 (the two cheapest
        // special edges from the depot)
        assert!(
            neighbors[0].contains(&1),
            "Node 0 neighbors should contain 1, got {:?}",
            neighbors[0]
        );

        // Node 2's nearest should include its MST-adjacent nodes 1 and 3
        assert!(
            neighbors[2].contains(&1) || neighbors[2].contains(&3),
            "Node 2 neighbors should contain 1 or 3, got {:?}",
            neighbors[2]
        );

        // Node 4's nearest should include 3 (direct MST neighbor)
        assert!(
            neighbors[4].contains(&3),
            "Node 4 neighbors should contain 3, got {:?}",
            neighbors[4]
        );
    }

    /// Verify that alpha-nearest neighbors correctly orders by alpha value.
    #[test]
    fn test_alpha_nearest_neighbors_ordering() {
        // Square graph: tour edges cheap (1), diagonals expensive (10)
        let costs = [
            [0.0, 1.0, 10.0, 1.0],
            [1.0, 0.0, 1.0, 10.0],
            [10.0, 1.0, 0.0, 1.0],
            [1.0, 10.0, 1.0, 0.0],
        ];

        let neighbors = alpha_nearest_neighbors(4, |i, j| costs[i][j], 3);

        // Each node should have 3 neighbors (all others)
        for n in &neighbors {
            assert_eq!(n.len(), 3);
        }

        // Node 0's best neighbors should be 1 and 3 (cost 1 each), not 2 (cost 10)
        // So 2 should be last in the neighbor list
        assert_eq!(
            neighbors[0][2], 2,
            "Node 2 should be node 0's worst neighbor, got {:?}",
            neighbors[0]
        );
    }

    /// Alpha-nearness is symmetric, so neighbors should reflect that:
    /// if j is a top neighbor of i, then i should be a top neighbor of j
    /// (for small enough graphs where all neighbors are returned).
    #[test]
    fn test_alpha_nearness_symmetric() {
        let costs = [
            [0.0, 1.0, 10.0, 1.0],
            [1.0, 0.0, 1.0, 10.0],
            [10.0, 1.0, 0.0, 1.0],
            [1.0, 10.0, 1.0, 0.0],
        ];
        let neighbors = alpha_nearest_neighbors(4, |i, j| costs[i][j], 3);

        // With k=3 and 4 nodes, every node gets all others as neighbors.
        // Check symmetry: if j appears in neighbors[i], then i appears in neighbors[j].
        for i in 0..4 {
            for &j in &neighbors[i] {
                assert!(
                    neighbors[j].contains(&i),
                    "Node {} is neighbor of {} but {} is not neighbor of {}",
                    j,
                    i,
                    i,
                    j
                );
            }
        }
    }

    #[test]
    fn test_alpha_nearest_two_nodes() {
        let neighbors = alpha_nearest_neighbors(2, |_, _| 5.0, 1);
        assert_eq!(neighbors[0], vec![1]);
        assert_eq!(neighbors[1], vec![0]);
    }
}
