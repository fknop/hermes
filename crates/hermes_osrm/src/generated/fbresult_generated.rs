// automatically generated by the FlatBuffers compiler, do not modify
// @generated

extern crate alloc;

#[allow(unused_imports, dead_code)]
pub mod osrm {

extern crate alloc;
#[allow(unused_imports, dead_code)]
pub mod engine {

extern crate alloc;
#[allow(unused_imports, dead_code)]
pub mod api {

extern crate alloc;
#[allow(unused_imports, dead_code)]
pub mod fbresult {

extern crate alloc;

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MANEUVER_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MANEUVER_TYPE: i8 = 15;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MANEUVER_TYPE: [ManeuverType; 16] = [
  ManeuverType::Turn,
  ManeuverType::NewName,
  ManeuverType::Depart,
  ManeuverType::Arrive,
  ManeuverType::Merge,
  ManeuverType::OnRamp,
  ManeuverType::OffRamp,
  ManeuverType::Fork,
  ManeuverType::EndOfRoad,
  ManeuverType::Continue,
  ManeuverType::Roundabout,
  ManeuverType::Rotary,
  ManeuverType::RoundaboutTurn,
  ManeuverType::Notification,
  ManeuverType::ExitRoundabout,
  ManeuverType::ExitRotary,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ManeuverType(pub i8);
#[allow(non_upper_case_globals)]
impl ManeuverType {
  pub const Turn: Self = Self(0);
  pub const NewName: Self = Self(1);
  pub const Depart: Self = Self(2);
  pub const Arrive: Self = Self(3);
  pub const Merge: Self = Self(4);
  pub const OnRamp: Self = Self(5);
  pub const OffRamp: Self = Self(6);
  pub const Fork: Self = Self(7);
  pub const EndOfRoad: Self = Self(8);
  pub const Continue: Self = Self(9);
  pub const Roundabout: Self = Self(10);
  pub const Rotary: Self = Self(11);
  pub const RoundaboutTurn: Self = Self(12);
  pub const Notification: Self = Self(13);
  pub const ExitRoundabout: Self = Self(14);
  pub const ExitRotary: Self = Self(15);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 15;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Turn,
    Self::NewName,
    Self::Depart,
    Self::Arrive,
    Self::Merge,
    Self::OnRamp,
    Self::OffRamp,
    Self::Fork,
    Self::EndOfRoad,
    Self::Continue,
    Self::Roundabout,
    Self::Rotary,
    Self::RoundaboutTurn,
    Self::Notification,
    Self::ExitRoundabout,
    Self::ExitRotary,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Turn => Some("Turn"),
      Self::NewName => Some("NewName"),
      Self::Depart => Some("Depart"),
      Self::Arrive => Some("Arrive"),
      Self::Merge => Some("Merge"),
      Self::OnRamp => Some("OnRamp"),
      Self::OffRamp => Some("OffRamp"),
      Self::Fork => Some("Fork"),
      Self::EndOfRoad => Some("EndOfRoad"),
      Self::Continue => Some("Continue"),
      Self::Roundabout => Some("Roundabout"),
      Self::Rotary => Some("Rotary"),
      Self::RoundaboutTurn => Some("RoundaboutTurn"),
      Self::Notification => Some("Notification"),
      Self::ExitRoundabout => Some("ExitRoundabout"),
      Self::ExitRotary => Some("ExitRotary"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for ManeuverType {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for ManeuverType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for ManeuverType {
    type Output = ManeuverType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for ManeuverType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for ManeuverType {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    i8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for ManeuverType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TURN: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TURN: i8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TURN: [Turn; 9] = [
  Turn::None,
  Turn::UTurn,
  Turn::SharpRight,
  Turn::Right,
  Turn::SlightRight,
  Turn::Straight,
  Turn::SlightLeft,
  Turn::Left,
  Turn::SharpLeft,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Turn(pub i8);
#[allow(non_upper_case_globals)]
impl Turn {
  pub const None: Self = Self(0);
  pub const UTurn: Self = Self(1);
  pub const SharpRight: Self = Self(2);
  pub const Right: Self = Self(3);
  pub const SlightRight: Self = Self(4);
  pub const Straight: Self = Self(5);
  pub const SlightLeft: Self = Self(6);
  pub const Left: Self = Self(7);
  pub const SharpLeft: Self = Self(8);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::None,
    Self::UTurn,
    Self::SharpRight,
    Self::Right,
    Self::SlightRight,
    Self::Straight,
    Self::SlightLeft,
    Self::Left,
    Self::SharpLeft,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::None => Some("None"),
      Self::UTurn => Some("UTurn"),
      Self::SharpRight => Some("SharpRight"),
      Self::Right => Some("Right"),
      Self::SlightRight => Some("SlightRight"),
      Self::Straight => Some("Straight"),
      Self::SlightLeft => Some("SlightLeft"),
      Self::Left => Some("Left"),
      Self::SharpLeft => Some("SharpLeft"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for Turn {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for Turn {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for Turn {
    type Output = Turn;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for Turn {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for Turn {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    i8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for Turn {}
// struct Position, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Position(pub [u8; 8]);
impl Default for Position { 
  fn default() -> Self { 
    Self([0; 8])
  }
}
impl ::core::fmt::Debug for Position {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    f.debug_struct("Position")
      .field("longitude", &self.longitude())
      .field("latitude", &self.latitude())
      .finish()
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for Position {}
impl<'a> ::flatbuffers::Follow<'a> for Position {
  type Inner = &'a Position;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { <&'a Position>::follow(buf, loc) }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for &'a Position {
  type Inner = &'a Position;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { ::flatbuffers::follow_cast_ref::<Position>(buf, loc) }
  }
}
impl<'b> ::flatbuffers::Push for Position {
    type Output = Position;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = unsafe { ::core::slice::from_raw_parts(self as *const Position as *const u8, <Self as ::flatbuffers::Push>::size()) };
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> ::flatbuffers::PushAlignment {
        ::flatbuffers::PushAlignment::new(4)
    }
}

impl<'a> ::flatbuffers::Verifiable for Position {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Position {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    longitude: f32,
    latitude: f32,
  ) -> Self {
    let mut s = Self([0; 8]);
    s.set_longitude(longitude);
    s.set_latitude(latitude);
    s
  }

  pub fn longitude(&self) -> f32 {
    let mut mem = ::core::mem::MaybeUninit::<<f32 as ::flatbuffers::EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    ::flatbuffers::EndianScalar::from_little_endian(unsafe {
      ::core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        ::core::mem::size_of::<<f32 as ::flatbuffers::EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_longitude(&mut self, x: f32) {
    let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      ::core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        ::core::mem::size_of::<<f32 as ::flatbuffers::EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn latitude(&self) -> f32 {
    let mut mem = ::core::mem::MaybeUninit::<<f32 as ::flatbuffers::EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    ::flatbuffers::EndianScalar::from_little_endian(unsafe {
      ::core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        ::core::mem::size_of::<<f32 as ::flatbuffers::EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_latitude(&mut self, x: f32) {
    let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      ::core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        ::core::mem::size_of::<<f32 as ::flatbuffers::EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct Uint64Pair, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Uint64Pair(pub [u8; 16]);
impl Default for Uint64Pair { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl ::core::fmt::Debug for Uint64Pair {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    f.debug_struct("Uint64Pair")
      .field("first", &self.first())
      .field("second", &self.second())
      .finish()
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for Uint64Pair {}
impl<'a> ::flatbuffers::Follow<'a> for Uint64Pair {
  type Inner = &'a Uint64Pair;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { <&'a Uint64Pair>::follow(buf, loc) }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for &'a Uint64Pair {
  type Inner = &'a Uint64Pair;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { ::flatbuffers::follow_cast_ref::<Uint64Pair>(buf, loc) }
  }
}
impl<'b> ::flatbuffers::Push for Uint64Pair {
    type Output = Uint64Pair;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = unsafe { ::core::slice::from_raw_parts(self as *const Uint64Pair as *const u8, <Self as ::flatbuffers::Push>::size()) };
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> ::flatbuffers::PushAlignment {
        ::flatbuffers::PushAlignment::new(8)
    }
}

impl<'a> ::flatbuffers::Verifiable for Uint64Pair {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Uint64Pair {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    first: u64,
    second: u64,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_first(first);
    s.set_second(second);
    s
  }

  pub fn first(&self) -> u64 {
    let mut mem = ::core::mem::MaybeUninit::<<u64 as ::flatbuffers::EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    ::flatbuffers::EndianScalar::from_little_endian(unsafe {
      ::core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        ::core::mem::size_of::<<u64 as ::flatbuffers::EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_first(&mut self, x: u64) {
    let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      ::core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        ::core::mem::size_of::<<u64 as ::flatbuffers::EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn second(&self) -> u64 {
    let mut mem = ::core::mem::MaybeUninit::<<u64 as ::flatbuffers::EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    ::flatbuffers::EndianScalar::from_little_endian(unsafe {
      ::core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        ::core::mem::size_of::<<u64 as ::flatbuffers::EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_second(&mut self, x: u64) {
    let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      ::core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        ::core::mem::size_of::<<u64 as ::flatbuffers::EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum WaypointOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Waypoint<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Waypoint<'a> {
  type Inner = Waypoint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Waypoint<'a> {
  pub const VT_HINT: ::flatbuffers::VOffsetT = 4;
  pub const VT_DISTANCE: ::flatbuffers::VOffsetT = 6;
  pub const VT_NAME: ::flatbuffers::VOffsetT = 8;
  pub const VT_LOCATION: ::flatbuffers::VOffsetT = 10;
  pub const VT_NODES: ::flatbuffers::VOffsetT = 12;
  pub const VT_MATCHINGS_INDEX: ::flatbuffers::VOffsetT = 14;
  pub const VT_WAYPOINT_INDEX: ::flatbuffers::VOffsetT = 16;
  pub const VT_ALTERNATIVES_COUNT: ::flatbuffers::VOffsetT = 18;
  pub const VT_TRIPS_INDEX: ::flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Waypoint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args WaypointArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Waypoint<'bldr>> {
    let mut builder = WaypointBuilder::new(_fbb);
    builder.add_trips_index(args.trips_index);
    builder.add_alternatives_count(args.alternatives_count);
    builder.add_waypoint_index(args.waypoint_index);
    builder.add_matchings_index(args.matchings_index);
    if let Some(x) = args.nodes { builder.add_nodes(x); }
    if let Some(x) = args.location { builder.add_location(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_distance(args.distance);
    if let Some(x) = args.hint { builder.add_hint(x); }
    builder.finish()
  }


  #[inline]
  pub fn hint(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Waypoint::VT_HINT, None)}
  }
  #[inline]
  pub fn distance(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Waypoint::VT_DISTANCE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Waypoint::VT_NAME, None)}
  }
  #[inline]
  pub fn location(&self) -> Option<&'a Position> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Position>(Waypoint::VT_LOCATION, None)}
  }
  #[inline]
  pub fn nodes(&self) -> Option<&'a Uint64Pair> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Uint64Pair>(Waypoint::VT_NODES, None)}
  }
  #[inline]
  pub fn matchings_index(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Waypoint::VT_MATCHINGS_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn waypoint_index(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Waypoint::VT_WAYPOINT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn alternatives_count(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Waypoint::VT_ALTERNATIVES_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn trips_index(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Waypoint::VT_TRIPS_INDEX, Some(0)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for Waypoint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("hint", Self::VT_HINT, false)?
     .visit_field::<f32>("distance", Self::VT_DISTANCE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<Position>("location", Self::VT_LOCATION, false)?
     .visit_field::<Uint64Pair>("nodes", Self::VT_NODES, false)?
     .visit_field::<u32>("matchings_index", Self::VT_MATCHINGS_INDEX, false)?
     .visit_field::<u32>("waypoint_index", Self::VT_WAYPOINT_INDEX, false)?
     .visit_field::<u32>("alternatives_count", Self::VT_ALTERNATIVES_COUNT, false)?
     .visit_field::<u32>("trips_index", Self::VT_TRIPS_INDEX, false)?
     .finish();
    Ok(())
  }
}
pub struct WaypointArgs<'a> {
    pub hint: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub distance: f32,
    pub name: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub location: Option<&'a Position>,
    pub nodes: Option<&'a Uint64Pair>,
    pub matchings_index: u32,
    pub waypoint_index: u32,
    pub alternatives_count: u32,
    pub trips_index: u32,
}
impl<'a> Default for WaypointArgs<'a> {
  #[inline]
  fn default() -> Self {
    WaypointArgs {
      hint: None,
      distance: 0.0,
      name: None,
      location: None,
      nodes: None,
      matchings_index: 0,
      waypoint_index: 0,
      alternatives_count: 0,
      trips_index: 0,
    }
  }
}

pub struct WaypointBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> WaypointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_hint(&mut self, hint: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Waypoint::VT_HINT, hint);
  }
  #[inline]
  pub fn add_distance(&mut self, distance: f32) {
    self.fbb_.push_slot::<f32>(Waypoint::VT_DISTANCE, distance, 0.0);
  }
  #[inline]
  pub fn add_name(&mut self, name: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Waypoint::VT_NAME, name);
  }
  #[inline]
  pub fn add_location(&mut self, location: &Position) {
    self.fbb_.push_slot_always::<&Position>(Waypoint::VT_LOCATION, location);
  }
  #[inline]
  pub fn add_nodes(&mut self, nodes: &Uint64Pair) {
    self.fbb_.push_slot_always::<&Uint64Pair>(Waypoint::VT_NODES, nodes);
  }
  #[inline]
  pub fn add_matchings_index(&mut self, matchings_index: u32) {
    self.fbb_.push_slot::<u32>(Waypoint::VT_MATCHINGS_INDEX, matchings_index, 0);
  }
  #[inline]
  pub fn add_waypoint_index(&mut self, waypoint_index: u32) {
    self.fbb_.push_slot::<u32>(Waypoint::VT_WAYPOINT_INDEX, waypoint_index, 0);
  }
  #[inline]
  pub fn add_alternatives_count(&mut self, alternatives_count: u32) {
    self.fbb_.push_slot::<u32>(Waypoint::VT_ALTERNATIVES_COUNT, alternatives_count, 0);
  }
  #[inline]
  pub fn add_trips_index(&mut self, trips_index: u32) {
    self.fbb_.push_slot::<u32>(Waypoint::VT_TRIPS_INDEX, trips_index, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> WaypointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    WaypointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Waypoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Waypoint<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Waypoint");
      ds.field("hint", &self.hint());
      ds.field("distance", &self.distance());
      ds.field("name", &self.name());
      ds.field("location", &self.location());
      ds.field("nodes", &self.nodes());
      ds.field("matchings_index", &self.matchings_index());
      ds.field("waypoint_index", &self.waypoint_index());
      ds.field("alternatives_count", &self.alternatives_count());
      ds.field("trips_index", &self.trips_index());
      ds.finish()
  }
}
pub enum MetadataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Metadata<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Metadata<'a> {
  type Inner = Metadata<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Metadata<'a> {
  pub const VT_DATASOURCE_NAMES: ::flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Metadata { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MetadataArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Metadata<'bldr>> {
    let mut builder = MetadataBuilder::new(_fbb);
    if let Some(x) = args.datasource_names { builder.add_datasource_names(x); }
    builder.finish()
  }


  #[inline]
  pub fn datasource_names(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>>>(Metadata::VT_DATASOURCE_NAMES, None)}
  }
}

impl ::flatbuffers::Verifiable for Metadata<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<&'_ str>>>>("datasource_names", Self::VT_DATASOURCE_NAMES, false)?
     .finish();
    Ok(())
  }
}
pub struct MetadataArgs<'a> {
    pub datasource_names: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for MetadataArgs<'a> {
  #[inline]
  fn default() -> Self {
    MetadataArgs {
      datasource_names: None,
    }
  }
}

pub struct MetadataBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> MetadataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_datasource_names(&mut self, datasource_names: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Metadata::VT_DATASOURCE_NAMES, datasource_names);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> MetadataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MetadataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Metadata<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Metadata<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Metadata");
      ds.field("datasource_names", &self.datasource_names());
      ds.finish()
  }
}
pub enum AnnotationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Annotation<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Annotation<'a> {
  type Inner = Annotation<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Annotation<'a> {
  pub const VT_DISTANCE: ::flatbuffers::VOffsetT = 4;
  pub const VT_DURATION: ::flatbuffers::VOffsetT = 6;
  pub const VT_DATASOURCES: ::flatbuffers::VOffsetT = 8;
  pub const VT_NODES: ::flatbuffers::VOffsetT = 10;
  pub const VT_WEIGHT: ::flatbuffers::VOffsetT = 12;
  pub const VT_SPEED: ::flatbuffers::VOffsetT = 14;
  pub const VT_METADATA: ::flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Annotation { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AnnotationArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Annotation<'bldr>> {
    let mut builder = AnnotationBuilder::new(_fbb);
    if let Some(x) = args.metadata { builder.add_metadata(x); }
    if let Some(x) = args.speed { builder.add_speed(x); }
    if let Some(x) = args.weight { builder.add_weight(x); }
    if let Some(x) = args.nodes { builder.add_nodes(x); }
    if let Some(x) = args.datasources { builder.add_datasources(x); }
    if let Some(x) = args.duration { builder.add_duration(x); }
    if let Some(x) = args.distance { builder.add_distance(x); }
    builder.finish()
  }


  #[inline]
  pub fn distance(&self) -> Option<::flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u32>>>(Annotation::VT_DISTANCE, None)}
  }
  #[inline]
  pub fn duration(&self) -> Option<::flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u32>>>(Annotation::VT_DURATION, None)}
  }
  #[inline]
  pub fn datasources(&self) -> Option<::flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u32>>>(Annotation::VT_DATASOURCES, None)}
  }
  #[inline]
  pub fn nodes(&self) -> Option<::flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u32>>>(Annotation::VT_NODES, None)}
  }
  #[inline]
  pub fn weight(&self) -> Option<::flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u32>>>(Annotation::VT_WEIGHT, None)}
  }
  #[inline]
  pub fn speed(&self) -> Option<::flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, f32>>>(Annotation::VT_SPEED, None)}
  }
  #[inline]
  pub fn metadata(&self) -> Option<Metadata<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<Metadata>>(Annotation::VT_METADATA, None)}
  }
}

impl ::flatbuffers::Verifiable for Annotation<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u32>>>("distance", Self::VT_DISTANCE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u32>>>("duration", Self::VT_DURATION, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u32>>>("datasources", Self::VT_DATASOURCES, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u32>>>("nodes", Self::VT_NODES, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u32>>>("weight", Self::VT_WEIGHT, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, f32>>>("speed", Self::VT_SPEED, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<Metadata>>("metadata", Self::VT_METADATA, false)?
     .finish();
    Ok(())
  }
}
pub struct AnnotationArgs<'a> {
    pub distance: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u32>>>,
    pub duration: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u32>>>,
    pub datasources: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u32>>>,
    pub nodes: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u32>>>,
    pub weight: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u32>>>,
    pub speed: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, f32>>>,
    pub metadata: Option<::flatbuffers::WIPOffset<Metadata<'a>>>,
}
impl<'a> Default for AnnotationArgs<'a> {
  #[inline]
  fn default() -> Self {
    AnnotationArgs {
      distance: None,
      duration: None,
      datasources: None,
      nodes: None,
      weight: None,
      speed: None,
      metadata: None,
    }
  }
}

pub struct AnnotationBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> AnnotationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_distance(&mut self, distance: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Annotation::VT_DISTANCE, distance);
  }
  #[inline]
  pub fn add_duration(&mut self, duration: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Annotation::VT_DURATION, duration);
  }
  #[inline]
  pub fn add_datasources(&mut self, datasources: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Annotation::VT_DATASOURCES, datasources);
  }
  #[inline]
  pub fn add_nodes(&mut self, nodes: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Annotation::VT_NODES, nodes);
  }
  #[inline]
  pub fn add_weight(&mut self, weight: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Annotation::VT_WEIGHT, weight);
  }
  #[inline]
  pub fn add_speed(&mut self, speed: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Annotation::VT_SPEED, speed);
  }
  #[inline]
  pub fn add_metadata(&mut self, metadata: ::flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<Metadata>>(Annotation::VT_METADATA, metadata);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> AnnotationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AnnotationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Annotation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Annotation<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Annotation");
      ds.field("distance", &self.distance());
      ds.field("duration", &self.duration());
      ds.field("datasources", &self.datasources());
      ds.field("nodes", &self.nodes());
      ds.field("weight", &self.weight());
      ds.field("speed", &self.speed());
      ds.field("metadata", &self.metadata());
      ds.finish()
  }
}
pub enum StepManeuverOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StepManeuver<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for StepManeuver<'a> {
  type Inner = StepManeuver<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> StepManeuver<'a> {
  pub const VT_LOCATION: ::flatbuffers::VOffsetT = 4;
  pub const VT_BEARING_BEFORE: ::flatbuffers::VOffsetT = 6;
  pub const VT_BEARING_AFTER: ::flatbuffers::VOffsetT = 8;
  pub const VT_TYPE_: ::flatbuffers::VOffsetT = 10;
  pub const VT_MODIFIER: ::flatbuffers::VOffsetT = 12;
  pub const VT_EXIT: ::flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    StepManeuver { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StepManeuverArgs<'args>
  ) -> ::flatbuffers::WIPOffset<StepManeuver<'bldr>> {
    let mut builder = StepManeuverBuilder::new(_fbb);
    if let Some(x) = args.location { builder.add_location(x); }
    builder.add_bearing_after(args.bearing_after);
    builder.add_bearing_before(args.bearing_before);
    builder.add_exit(args.exit);
    builder.add_modifier(args.modifier);
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn location(&self) -> Option<&'a Position> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Position>(StepManeuver::VT_LOCATION, None)}
  }
  #[inline]
  pub fn bearing_before(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(StepManeuver::VT_BEARING_BEFORE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn bearing_after(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(StepManeuver::VT_BEARING_AFTER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn type_(&self) -> ManeuverType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ManeuverType>(StepManeuver::VT_TYPE_, Some(ManeuverType::Turn)).unwrap()}
  }
  #[inline]
  pub fn modifier(&self) -> Turn {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Turn>(StepManeuver::VT_MODIFIER, Some(Turn::None)).unwrap()}
  }
  #[inline]
  pub fn exit(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(StepManeuver::VT_EXIT, Some(0)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for StepManeuver<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<Position>("location", Self::VT_LOCATION, false)?
     .visit_field::<u16>("bearing_before", Self::VT_BEARING_BEFORE, false)?
     .visit_field::<u16>("bearing_after", Self::VT_BEARING_AFTER, false)?
     .visit_field::<ManeuverType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<Turn>("modifier", Self::VT_MODIFIER, false)?
     .visit_field::<u8>("exit", Self::VT_EXIT, false)?
     .finish();
    Ok(())
  }
}
pub struct StepManeuverArgs<'a> {
    pub location: Option<&'a Position>,
    pub bearing_before: u16,
    pub bearing_after: u16,
    pub type_: ManeuverType,
    pub modifier: Turn,
    pub exit: u8,
}
impl<'a> Default for StepManeuverArgs<'a> {
  #[inline]
  fn default() -> Self {
    StepManeuverArgs {
      location: None,
      bearing_before: 0,
      bearing_after: 0,
      type_: ManeuverType::Turn,
      modifier: Turn::None,
      exit: 0,
    }
  }
}

pub struct StepManeuverBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> StepManeuverBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_location(&mut self, location: &Position) {
    self.fbb_.push_slot_always::<&Position>(StepManeuver::VT_LOCATION, location);
  }
  #[inline]
  pub fn add_bearing_before(&mut self, bearing_before: u16) {
    self.fbb_.push_slot::<u16>(StepManeuver::VT_BEARING_BEFORE, bearing_before, 0);
  }
  #[inline]
  pub fn add_bearing_after(&mut self, bearing_after: u16) {
    self.fbb_.push_slot::<u16>(StepManeuver::VT_BEARING_AFTER, bearing_after, 0);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: ManeuverType) {
    self.fbb_.push_slot::<ManeuverType>(StepManeuver::VT_TYPE_, type_, ManeuverType::Turn);
  }
  #[inline]
  pub fn add_modifier(&mut self, modifier: Turn) {
    self.fbb_.push_slot::<Turn>(StepManeuver::VT_MODIFIER, modifier, Turn::None);
  }
  #[inline]
  pub fn add_exit(&mut self, exit: u8) {
    self.fbb_.push_slot::<u8>(StepManeuver::VT_EXIT, exit, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> StepManeuverBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StepManeuverBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<StepManeuver<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for StepManeuver<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("StepManeuver");
      ds.field("location", &self.location());
      ds.field("bearing_before", &self.bearing_before());
      ds.field("bearing_after", &self.bearing_after());
      ds.field("type_", &self.type_());
      ds.field("modifier", &self.modifier());
      ds.field("exit", &self.exit());
      ds.finish()
  }
}
pub enum LaneOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Lane<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Lane<'a> {
  type Inner = Lane<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Lane<'a> {
  pub const VT_INDICATIONS: ::flatbuffers::VOffsetT = 4;
  pub const VT_VALID: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Lane { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LaneArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Lane<'bldr>> {
    let mut builder = LaneBuilder::new(_fbb);
    if let Some(x) = args.indications { builder.add_indications(x); }
    builder.add_valid(args.valid);
    builder.finish()
  }


  #[inline]
  pub fn indications(&self) -> Option<::flatbuffers::Vector<'a, Turn>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, Turn>>>(Lane::VT_INDICATIONS, None)}
  }
  #[inline]
  pub fn valid(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Lane::VT_VALID, Some(false)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for Lane<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, Turn>>>("indications", Self::VT_INDICATIONS, false)?
     .visit_field::<bool>("valid", Self::VT_VALID, false)?
     .finish();
    Ok(())
  }
}
pub struct LaneArgs<'a> {
    pub indications: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, Turn>>>,
    pub valid: bool,
}
impl<'a> Default for LaneArgs<'a> {
  #[inline]
  fn default() -> Self {
    LaneArgs {
      indications: None,
      valid: false,
    }
  }
}

pub struct LaneBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> LaneBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_indications(&mut self, indications: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , Turn>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Lane::VT_INDICATIONS, indications);
  }
  #[inline]
  pub fn add_valid(&mut self, valid: bool) {
    self.fbb_.push_slot::<bool>(Lane::VT_VALID, valid, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> LaneBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LaneBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Lane<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Lane<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Lane");
      ds.field("indications", &self.indications());
      ds.field("valid", &self.valid());
      ds.finish()
  }
}
pub enum IntersectionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Intersection<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Intersection<'a> {
  type Inner = Intersection<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Intersection<'a> {
  pub const VT_LOCATION: ::flatbuffers::VOffsetT = 4;
  pub const VT_BEARINGS: ::flatbuffers::VOffsetT = 6;
  pub const VT_CLASSES: ::flatbuffers::VOffsetT = 8;
  pub const VT_ENTRY: ::flatbuffers::VOffsetT = 10;
  pub const VT_IN_BEARING: ::flatbuffers::VOffsetT = 12;
  pub const VT_OUT_BEARING: ::flatbuffers::VOffsetT = 14;
  pub const VT_LANES: ::flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Intersection { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IntersectionArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Intersection<'bldr>> {
    let mut builder = IntersectionBuilder::new(_fbb);
    if let Some(x) = args.lanes { builder.add_lanes(x); }
    builder.add_out_bearing(args.out_bearing);
    builder.add_in_bearing(args.in_bearing);
    if let Some(x) = args.entry { builder.add_entry(x); }
    if let Some(x) = args.classes { builder.add_classes(x); }
    if let Some(x) = args.bearings { builder.add_bearings(x); }
    if let Some(x) = args.location { builder.add_location(x); }
    builder.finish()
  }


  #[inline]
  pub fn location(&self) -> Option<&'a Position> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Position>(Intersection::VT_LOCATION, None)}
  }
  #[inline]
  pub fn bearings(&self) -> Option<::flatbuffers::Vector<'a, i16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, i16>>>(Intersection::VT_BEARINGS, None)}
  }
  #[inline]
  pub fn classes(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>>>(Intersection::VT_CLASSES, None)}
  }
  #[inline]
  pub fn entry(&self) -> Option<::flatbuffers::Vector<'a, bool>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, bool>>>(Intersection::VT_ENTRY, None)}
  }
  #[inline]
  pub fn in_bearing(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Intersection::VT_IN_BEARING, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_bearing(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Intersection::VT_OUT_BEARING, Some(0)).unwrap()}
  }
  #[inline]
  pub fn lanes(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Lane<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Lane>>>>(Intersection::VT_LANES, None)}
  }
}

impl ::flatbuffers::Verifiable for Intersection<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<Position>("location", Self::VT_LOCATION, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, i16>>>("bearings", Self::VT_BEARINGS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<&'_ str>>>>("classes", Self::VT_CLASSES, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, bool>>>("entry", Self::VT_ENTRY, false)?
     .visit_field::<u32>("in_bearing", Self::VT_IN_BEARING, false)?
     .visit_field::<u32>("out_bearing", Self::VT_OUT_BEARING, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Lane>>>>("lanes", Self::VT_LANES, false)?
     .finish();
    Ok(())
  }
}
pub struct IntersectionArgs<'a> {
    pub location: Option<&'a Position>,
    pub bearings: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, i16>>>,
    pub classes: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub entry: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, bool>>>,
    pub in_bearing: u32,
    pub out_bearing: u32,
    pub lanes: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Lane<'a>>>>>,
}
impl<'a> Default for IntersectionArgs<'a> {
  #[inline]
  fn default() -> Self {
    IntersectionArgs {
      location: None,
      bearings: None,
      classes: None,
      entry: None,
      in_bearing: 0,
      out_bearing: 0,
      lanes: None,
    }
  }
}

pub struct IntersectionBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> IntersectionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_location(&mut self, location: &Position) {
    self.fbb_.push_slot_always::<&Position>(Intersection::VT_LOCATION, location);
  }
  #[inline]
  pub fn add_bearings(&mut self, bearings: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , i16>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Intersection::VT_BEARINGS, bearings);
  }
  #[inline]
  pub fn add_classes(&mut self, classes: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Intersection::VT_CLASSES, classes);
  }
  #[inline]
  pub fn add_entry(&mut self, entry: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , bool>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Intersection::VT_ENTRY, entry);
  }
  #[inline]
  pub fn add_in_bearing(&mut self, in_bearing: u32) {
    self.fbb_.push_slot::<u32>(Intersection::VT_IN_BEARING, in_bearing, 0);
  }
  #[inline]
  pub fn add_out_bearing(&mut self, out_bearing: u32) {
    self.fbb_.push_slot::<u32>(Intersection::VT_OUT_BEARING, out_bearing, 0);
  }
  #[inline]
  pub fn add_lanes(&mut self, lanes: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<Lane<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Intersection::VT_LANES, lanes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> IntersectionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IntersectionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Intersection<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Intersection<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Intersection");
      ds.field("location", &self.location());
      ds.field("bearings", &self.bearings());
      ds.field("classes", &self.classes());
      ds.field("entry", &self.entry());
      ds.field("in_bearing", &self.in_bearing());
      ds.field("out_bearing", &self.out_bearing());
      ds.field("lanes", &self.lanes());
      ds.finish()
  }
}
pub enum StepOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Step<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Step<'a> {
  type Inner = Step<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Step<'a> {
  pub const VT_DISTANCE: ::flatbuffers::VOffsetT = 4;
  pub const VT_DURATION: ::flatbuffers::VOffsetT = 6;
  pub const VT_POLYLINE: ::flatbuffers::VOffsetT = 8;
  pub const VT_COORDINATES: ::flatbuffers::VOffsetT = 10;
  pub const VT_WEIGHT: ::flatbuffers::VOffsetT = 12;
  pub const VT_NAME: ::flatbuffers::VOffsetT = 14;
  pub const VT_REF_: ::flatbuffers::VOffsetT = 16;
  pub const VT_PRONUNCIATION: ::flatbuffers::VOffsetT = 18;
  pub const VT_DESTINATIONS: ::flatbuffers::VOffsetT = 20;
  pub const VT_EXITS: ::flatbuffers::VOffsetT = 22;
  pub const VT_MODE: ::flatbuffers::VOffsetT = 24;
  pub const VT_MANEUVER: ::flatbuffers::VOffsetT = 26;
  pub const VT_INTERSECTIONS: ::flatbuffers::VOffsetT = 28;
  pub const VT_ROTARY_NAME: ::flatbuffers::VOffsetT = 30;
  pub const VT_ROTARY_PRONUNCIATION: ::flatbuffers::VOffsetT = 32;
  pub const VT_DRIVING_SIDE: ::flatbuffers::VOffsetT = 34;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Step { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StepArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Step<'bldr>> {
    let mut builder = StepBuilder::new(_fbb);
    if let Some(x) = args.rotary_pronunciation { builder.add_rotary_pronunciation(x); }
    if let Some(x) = args.rotary_name { builder.add_rotary_name(x); }
    if let Some(x) = args.intersections { builder.add_intersections(x); }
    if let Some(x) = args.maneuver { builder.add_maneuver(x); }
    if let Some(x) = args.mode { builder.add_mode(x); }
    if let Some(x) = args.exits { builder.add_exits(x); }
    if let Some(x) = args.destinations { builder.add_destinations(x); }
    if let Some(x) = args.pronunciation { builder.add_pronunciation(x); }
    if let Some(x) = args.ref_ { builder.add_ref_(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_weight(args.weight);
    if let Some(x) = args.coordinates { builder.add_coordinates(x); }
    if let Some(x) = args.polyline { builder.add_polyline(x); }
    builder.add_duration(args.duration);
    builder.add_distance(args.distance);
    builder.add_driving_side(args.driving_side);
    builder.finish()
  }


  #[inline]
  pub fn distance(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Step::VT_DISTANCE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn duration(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Step::VT_DURATION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn polyline(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Step::VT_POLYLINE, None)}
  }
  #[inline]
  pub fn coordinates(&self) -> Option<::flatbuffers::Vector<'a, Position>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, Position>>>(Step::VT_COORDINATES, None)}
  }
  #[inline]
  pub fn weight(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Step::VT_WEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Step::VT_NAME, None)}
  }
  #[inline]
  pub fn ref_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Step::VT_REF_, None)}
  }
  #[inline]
  pub fn pronunciation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Step::VT_PRONUNCIATION, None)}
  }
  #[inline]
  pub fn destinations(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Step::VT_DESTINATIONS, None)}
  }
  #[inline]
  pub fn exits(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Step::VT_EXITS, None)}
  }
  #[inline]
  pub fn mode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Step::VT_MODE, None)}
  }
  #[inline]
  pub fn maneuver(&self) -> Option<StepManeuver<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<StepManeuver>>(Step::VT_MANEUVER, None)}
  }
  #[inline]
  pub fn intersections(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Intersection<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Intersection>>>>(Step::VT_INTERSECTIONS, None)}
  }
  #[inline]
  pub fn rotary_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Step::VT_ROTARY_NAME, None)}
  }
  #[inline]
  pub fn rotary_pronunciation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Step::VT_ROTARY_PRONUNCIATION, None)}
  }
  #[inline]
  pub fn driving_side(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Step::VT_DRIVING_SIDE, Some(false)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for Step<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<f32>("distance", Self::VT_DISTANCE, false)?
     .visit_field::<f32>("duration", Self::VT_DURATION, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("polyline", Self::VT_POLYLINE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, Position>>>("coordinates", Self::VT_COORDINATES, false)?
     .visit_field::<f32>("weight", Self::VT_WEIGHT, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("ref_", Self::VT_REF_, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("pronunciation", Self::VT_PRONUNCIATION, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("destinations", Self::VT_DESTINATIONS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("exits", Self::VT_EXITS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("mode", Self::VT_MODE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<StepManeuver>>("maneuver", Self::VT_MANEUVER, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Intersection>>>>("intersections", Self::VT_INTERSECTIONS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("rotary_name", Self::VT_ROTARY_NAME, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("rotary_pronunciation", Self::VT_ROTARY_PRONUNCIATION, false)?
     .visit_field::<bool>("driving_side", Self::VT_DRIVING_SIDE, false)?
     .finish();
    Ok(())
  }
}
pub struct StepArgs<'a> {
    pub distance: f32,
    pub duration: f32,
    pub polyline: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub coordinates: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, Position>>>,
    pub weight: f32,
    pub name: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub ref_: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub pronunciation: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub destinations: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub exits: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub mode: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub maneuver: Option<::flatbuffers::WIPOffset<StepManeuver<'a>>>,
    pub intersections: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Intersection<'a>>>>>,
    pub rotary_name: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub rotary_pronunciation: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub driving_side: bool,
}
impl<'a> Default for StepArgs<'a> {
  #[inline]
  fn default() -> Self {
    StepArgs {
      distance: 0.0,
      duration: 0.0,
      polyline: None,
      coordinates: None,
      weight: 0.0,
      name: None,
      ref_: None,
      pronunciation: None,
      destinations: None,
      exits: None,
      mode: None,
      maneuver: None,
      intersections: None,
      rotary_name: None,
      rotary_pronunciation: None,
      driving_side: false,
    }
  }
}

pub struct StepBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> StepBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_distance(&mut self, distance: f32) {
    self.fbb_.push_slot::<f32>(Step::VT_DISTANCE, distance, 0.0);
  }
  #[inline]
  pub fn add_duration(&mut self, duration: f32) {
    self.fbb_.push_slot::<f32>(Step::VT_DURATION, duration, 0.0);
  }
  #[inline]
  pub fn add_polyline(&mut self, polyline: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Step::VT_POLYLINE, polyline);
  }
  #[inline]
  pub fn add_coordinates(&mut self, coordinates: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , Position>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Step::VT_COORDINATES, coordinates);
  }
  #[inline]
  pub fn add_weight(&mut self, weight: f32) {
    self.fbb_.push_slot::<f32>(Step::VT_WEIGHT, weight, 0.0);
  }
  #[inline]
  pub fn add_name(&mut self, name: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Step::VT_NAME, name);
  }
  #[inline]
  pub fn add_ref_(&mut self, ref_: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Step::VT_REF_, ref_);
  }
  #[inline]
  pub fn add_pronunciation(&mut self, pronunciation: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Step::VT_PRONUNCIATION, pronunciation);
  }
  #[inline]
  pub fn add_destinations(&mut self, destinations: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Step::VT_DESTINATIONS, destinations);
  }
  #[inline]
  pub fn add_exits(&mut self, exits: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Step::VT_EXITS, exits);
  }
  #[inline]
  pub fn add_mode(&mut self, mode: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Step::VT_MODE, mode);
  }
  #[inline]
  pub fn add_maneuver(&mut self, maneuver: ::flatbuffers::WIPOffset<StepManeuver<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<StepManeuver>>(Step::VT_MANEUVER, maneuver);
  }
  #[inline]
  pub fn add_intersections(&mut self, intersections: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<Intersection<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Step::VT_INTERSECTIONS, intersections);
  }
  #[inline]
  pub fn add_rotary_name(&mut self, rotary_name: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Step::VT_ROTARY_NAME, rotary_name);
  }
  #[inline]
  pub fn add_rotary_pronunciation(&mut self, rotary_pronunciation: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Step::VT_ROTARY_PRONUNCIATION, rotary_pronunciation);
  }
  #[inline]
  pub fn add_driving_side(&mut self, driving_side: bool) {
    self.fbb_.push_slot::<bool>(Step::VT_DRIVING_SIDE, driving_side, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> StepBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StepBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Step<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Step<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Step");
      ds.field("distance", &self.distance());
      ds.field("duration", &self.duration());
      ds.field("polyline", &self.polyline());
      ds.field("coordinates", &self.coordinates());
      ds.field("weight", &self.weight());
      ds.field("name", &self.name());
      ds.field("ref_", &self.ref_());
      ds.field("pronunciation", &self.pronunciation());
      ds.field("destinations", &self.destinations());
      ds.field("exits", &self.exits());
      ds.field("mode", &self.mode());
      ds.field("maneuver", &self.maneuver());
      ds.field("intersections", &self.intersections());
      ds.field("rotary_name", &self.rotary_name());
      ds.field("rotary_pronunciation", &self.rotary_pronunciation());
      ds.field("driving_side", &self.driving_side());
      ds.finish()
  }
}
pub enum LegOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Leg<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Leg<'a> {
  type Inner = Leg<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Leg<'a> {
  pub const VT_DISTANCE: ::flatbuffers::VOffsetT = 4;
  pub const VT_DURATION: ::flatbuffers::VOffsetT = 6;
  pub const VT_WEIGHT: ::flatbuffers::VOffsetT = 8;
  pub const VT_SUMMARY: ::flatbuffers::VOffsetT = 10;
  pub const VT_ANNOTATIONS: ::flatbuffers::VOffsetT = 12;
  pub const VT_STEPS: ::flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Leg { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LegArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Leg<'bldr>> {
    let mut builder = LegBuilder::new(_fbb);
    builder.add_weight(args.weight);
    builder.add_duration(args.duration);
    builder.add_distance(args.distance);
    if let Some(x) = args.steps { builder.add_steps(x); }
    if let Some(x) = args.annotations { builder.add_annotations(x); }
    if let Some(x) = args.summary { builder.add_summary(x); }
    builder.finish()
  }


  #[inline]
  pub fn distance(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Leg::VT_DISTANCE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn duration(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Leg::VT_DURATION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn weight(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Leg::VT_WEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn summary(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Leg::VT_SUMMARY, None)}
  }
  #[inline]
  pub fn annotations(&self) -> Option<Annotation<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<Annotation>>(Leg::VT_ANNOTATIONS, None)}
  }
  #[inline]
  pub fn steps(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Step<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Step>>>>(Leg::VT_STEPS, None)}
  }
}

impl ::flatbuffers::Verifiable for Leg<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<f64>("distance", Self::VT_DISTANCE, false)?
     .visit_field::<f64>("duration", Self::VT_DURATION, false)?
     .visit_field::<f64>("weight", Self::VT_WEIGHT, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("summary", Self::VT_SUMMARY, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<Annotation>>("annotations", Self::VT_ANNOTATIONS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Step>>>>("steps", Self::VT_STEPS, false)?
     .finish();
    Ok(())
  }
}
pub struct LegArgs<'a> {
    pub distance: f64,
    pub duration: f64,
    pub weight: f64,
    pub summary: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub annotations: Option<::flatbuffers::WIPOffset<Annotation<'a>>>,
    pub steps: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Step<'a>>>>>,
}
impl<'a> Default for LegArgs<'a> {
  #[inline]
  fn default() -> Self {
    LegArgs {
      distance: 0.0,
      duration: 0.0,
      weight: 0.0,
      summary: None,
      annotations: None,
      steps: None,
    }
  }
}

pub struct LegBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> LegBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_distance(&mut self, distance: f64) {
    self.fbb_.push_slot::<f64>(Leg::VT_DISTANCE, distance, 0.0);
  }
  #[inline]
  pub fn add_duration(&mut self, duration: f64) {
    self.fbb_.push_slot::<f64>(Leg::VT_DURATION, duration, 0.0);
  }
  #[inline]
  pub fn add_weight(&mut self, weight: f64) {
    self.fbb_.push_slot::<f64>(Leg::VT_WEIGHT, weight, 0.0);
  }
  #[inline]
  pub fn add_summary(&mut self, summary: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Leg::VT_SUMMARY, summary);
  }
  #[inline]
  pub fn add_annotations(&mut self, annotations: ::flatbuffers::WIPOffset<Annotation<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<Annotation>>(Leg::VT_ANNOTATIONS, annotations);
  }
  #[inline]
  pub fn add_steps(&mut self, steps: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<Step<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Leg::VT_STEPS, steps);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> LegBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LegBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Leg<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Leg<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Leg");
      ds.field("distance", &self.distance());
      ds.field("duration", &self.duration());
      ds.field("weight", &self.weight());
      ds.field("summary", &self.summary());
      ds.field("annotations", &self.annotations());
      ds.field("steps", &self.steps());
      ds.finish()
  }
}
pub enum RouteObjectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RouteObject<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for RouteObject<'a> {
  type Inner = RouteObject<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> RouteObject<'a> {
  pub const VT_DISTANCE: ::flatbuffers::VOffsetT = 4;
  pub const VT_DURATION: ::flatbuffers::VOffsetT = 6;
  pub const VT_WEIGHT: ::flatbuffers::VOffsetT = 8;
  pub const VT_WEIGHT_NAME: ::flatbuffers::VOffsetT = 10;
  pub const VT_CONFIDENCE: ::flatbuffers::VOffsetT = 12;
  pub const VT_POLYLINE: ::flatbuffers::VOffsetT = 14;
  pub const VT_COORDINATES: ::flatbuffers::VOffsetT = 16;
  pub const VT_LEGS: ::flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    RouteObject { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RouteObjectArgs<'args>
  ) -> ::flatbuffers::WIPOffset<RouteObject<'bldr>> {
    let mut builder = RouteObjectBuilder::new(_fbb);
    if let Some(x) = args.legs { builder.add_legs(x); }
    if let Some(x) = args.coordinates { builder.add_coordinates(x); }
    if let Some(x) = args.polyline { builder.add_polyline(x); }
    builder.add_confidence(args.confidence);
    if let Some(x) = args.weight_name { builder.add_weight_name(x); }
    builder.add_weight(args.weight);
    builder.add_duration(args.duration);
    builder.add_distance(args.distance);
    builder.finish()
  }


  #[inline]
  pub fn distance(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(RouteObject::VT_DISTANCE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn duration(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(RouteObject::VT_DURATION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn weight(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(RouteObject::VT_WEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn weight_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(RouteObject::VT_WEIGHT_NAME, None)}
  }
  #[inline]
  pub fn confidence(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(RouteObject::VT_CONFIDENCE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn polyline(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(RouteObject::VT_POLYLINE, None)}
  }
  #[inline]
  pub fn coordinates(&self) -> Option<::flatbuffers::Vector<'a, Position>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, Position>>>(RouteObject::VT_COORDINATES, None)}
  }
  #[inline]
  pub fn legs(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Leg<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Leg>>>>(RouteObject::VT_LEGS, None)}
  }
}

impl ::flatbuffers::Verifiable for RouteObject<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<f32>("distance", Self::VT_DISTANCE, false)?
     .visit_field::<f32>("duration", Self::VT_DURATION, false)?
     .visit_field::<f32>("weight", Self::VT_WEIGHT, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("weight_name", Self::VT_WEIGHT_NAME, false)?
     .visit_field::<f32>("confidence", Self::VT_CONFIDENCE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("polyline", Self::VT_POLYLINE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, Position>>>("coordinates", Self::VT_COORDINATES, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Leg>>>>("legs", Self::VT_LEGS, false)?
     .finish();
    Ok(())
  }
}
pub struct RouteObjectArgs<'a> {
    pub distance: f32,
    pub duration: f32,
    pub weight: f32,
    pub weight_name: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub confidence: f32,
    pub polyline: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub coordinates: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, Position>>>,
    pub legs: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Leg<'a>>>>>,
}
impl<'a> Default for RouteObjectArgs<'a> {
  #[inline]
  fn default() -> Self {
    RouteObjectArgs {
      distance: 0.0,
      duration: 0.0,
      weight: 0.0,
      weight_name: None,
      confidence: 0.0,
      polyline: None,
      coordinates: None,
      legs: None,
    }
  }
}

pub struct RouteObjectBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> RouteObjectBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_distance(&mut self, distance: f32) {
    self.fbb_.push_slot::<f32>(RouteObject::VT_DISTANCE, distance, 0.0);
  }
  #[inline]
  pub fn add_duration(&mut self, duration: f32) {
    self.fbb_.push_slot::<f32>(RouteObject::VT_DURATION, duration, 0.0);
  }
  #[inline]
  pub fn add_weight(&mut self, weight: f32) {
    self.fbb_.push_slot::<f32>(RouteObject::VT_WEIGHT, weight, 0.0);
  }
  #[inline]
  pub fn add_weight_name(&mut self, weight_name: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(RouteObject::VT_WEIGHT_NAME, weight_name);
  }
  #[inline]
  pub fn add_confidence(&mut self, confidence: f32) {
    self.fbb_.push_slot::<f32>(RouteObject::VT_CONFIDENCE, confidence, 0.0);
  }
  #[inline]
  pub fn add_polyline(&mut self, polyline: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(RouteObject::VT_POLYLINE, polyline);
  }
  #[inline]
  pub fn add_coordinates(&mut self, coordinates: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , Position>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(RouteObject::VT_COORDINATES, coordinates);
  }
  #[inline]
  pub fn add_legs(&mut self, legs: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<Leg<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(RouteObject::VT_LEGS, legs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> RouteObjectBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RouteObjectBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<RouteObject<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for RouteObject<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("RouteObject");
      ds.field("distance", &self.distance());
      ds.field("duration", &self.duration());
      ds.field("weight", &self.weight());
      ds.field("weight_name", &self.weight_name());
      ds.field("confidence", &self.confidence());
      ds.field("polyline", &self.polyline());
      ds.field("coordinates", &self.coordinates());
      ds.field("legs", &self.legs());
      ds.finish()
  }
}
pub enum TableResultOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TableResult<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for TableResult<'a> {
  type Inner = TableResult<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> TableResult<'a> {
  pub const VT_DURATIONS: ::flatbuffers::VOffsetT = 4;
  pub const VT_ROWS: ::flatbuffers::VOffsetT = 6;
  pub const VT_COLS: ::flatbuffers::VOffsetT = 8;
  pub const VT_DISTANCES: ::flatbuffers::VOffsetT = 10;
  pub const VT_DESTINATIONS: ::flatbuffers::VOffsetT = 12;
  pub const VT_FALLBACK_SPEED_CELLS: ::flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    TableResult { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TableResultArgs<'args>
  ) -> ::flatbuffers::WIPOffset<TableResult<'bldr>> {
    let mut builder = TableResultBuilder::new(_fbb);
    if let Some(x) = args.fallback_speed_cells { builder.add_fallback_speed_cells(x); }
    if let Some(x) = args.destinations { builder.add_destinations(x); }
    if let Some(x) = args.distances { builder.add_distances(x); }
    if let Some(x) = args.durations { builder.add_durations(x); }
    builder.add_cols(args.cols);
    builder.add_rows(args.rows);
    builder.finish()
  }


  #[inline]
  pub fn durations(&self) -> Option<::flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, f32>>>(TableResult::VT_DURATIONS, None)}
  }
  #[inline]
  pub fn rows(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TableResult::VT_ROWS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn cols(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TableResult::VT_COLS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn distances(&self) -> Option<::flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, f32>>>(TableResult::VT_DISTANCES, None)}
  }
  #[inline]
  pub fn destinations(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Waypoint<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Waypoint>>>>(TableResult::VT_DESTINATIONS, None)}
  }
  #[inline]
  pub fn fallback_speed_cells(&self) -> Option<::flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u32>>>(TableResult::VT_FALLBACK_SPEED_CELLS, None)}
  }
}

impl ::flatbuffers::Verifiable for TableResult<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, f32>>>("durations", Self::VT_DURATIONS, false)?
     .visit_field::<u16>("rows", Self::VT_ROWS, false)?
     .visit_field::<u16>("cols", Self::VT_COLS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, f32>>>("distances", Self::VT_DISTANCES, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Waypoint>>>>("destinations", Self::VT_DESTINATIONS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u32>>>("fallback_speed_cells", Self::VT_FALLBACK_SPEED_CELLS, false)?
     .finish();
    Ok(())
  }
}
pub struct TableResultArgs<'a> {
    pub durations: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, f32>>>,
    pub rows: u16,
    pub cols: u16,
    pub distances: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, f32>>>,
    pub destinations: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Waypoint<'a>>>>>,
    pub fallback_speed_cells: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for TableResultArgs<'a> {
  #[inline]
  fn default() -> Self {
    TableResultArgs {
      durations: None,
      rows: 0,
      cols: 0,
      distances: None,
      destinations: None,
      fallback_speed_cells: None,
    }
  }
}

pub struct TableResultBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> TableResultBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_durations(&mut self, durations: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(TableResult::VT_DURATIONS, durations);
  }
  #[inline]
  pub fn add_rows(&mut self, rows: u16) {
    self.fbb_.push_slot::<u16>(TableResult::VT_ROWS, rows, 0);
  }
  #[inline]
  pub fn add_cols(&mut self, cols: u16) {
    self.fbb_.push_slot::<u16>(TableResult::VT_COLS, cols, 0);
  }
  #[inline]
  pub fn add_distances(&mut self, distances: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(TableResult::VT_DISTANCES, distances);
  }
  #[inline]
  pub fn add_destinations(&mut self, destinations: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<Waypoint<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(TableResult::VT_DESTINATIONS, destinations);
  }
  #[inline]
  pub fn add_fallback_speed_cells(&mut self, fallback_speed_cells: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(TableResult::VT_FALLBACK_SPEED_CELLS, fallback_speed_cells);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> TableResultBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TableResultBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<TableResult<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for TableResult<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("TableResult");
      ds.field("durations", &self.durations());
      ds.field("rows", &self.rows());
      ds.field("cols", &self.cols());
      ds.field("distances", &self.distances());
      ds.field("destinations", &self.destinations());
      ds.field("fallback_speed_cells", &self.fallback_speed_cells());
      ds.finish()
  }
}
pub enum ErrorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Error<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Error<'a> {
  type Inner = Error<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Error<'a> {
  pub const VT_CODE: ::flatbuffers::VOffsetT = 4;
  pub const VT_MESSAGE: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Error { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ErrorArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Error<'bldr>> {
    let mut builder = ErrorBuilder::new(_fbb);
    if let Some(x) = args.message { builder.add_message(x); }
    if let Some(x) = args.code { builder.add_code(x); }
    builder.finish()
  }


  #[inline]
  pub fn code(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Error::VT_CODE, None)}
  }
  #[inline]
  pub fn message(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Error::VT_MESSAGE, None)}
  }
}

impl ::flatbuffers::Verifiable for Error<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("code", Self::VT_CODE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct ErrorArgs<'a> {
    pub code: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub message: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ErrorArgs<'a> {
  #[inline]
  fn default() -> Self {
    ErrorArgs {
      code: None,
      message: None,
    }
  }
}

pub struct ErrorBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ErrorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_code(&mut self, code: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Error::VT_CODE, code);
  }
  #[inline]
  pub fn add_message(&mut self, message: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Error::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> ErrorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ErrorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Error<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Error<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Error");
      ds.field("code", &self.code());
      ds.field("message", &self.message());
      ds.finish()
  }
}
pub enum FBResultOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FBResult<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for FBResult<'a> {
  type Inner = FBResult<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> FBResult<'a> {
  pub const VT_ERROR: ::flatbuffers::VOffsetT = 4;
  pub const VT_CODE: ::flatbuffers::VOffsetT = 6;
  pub const VT_DATA_VERSION: ::flatbuffers::VOffsetT = 8;
  pub const VT_WAYPOINTS: ::flatbuffers::VOffsetT = 10;
  pub const VT_ROUTES: ::flatbuffers::VOffsetT = 12;
  pub const VT_TABLE: ::flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    FBResult { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FBResultArgs<'args>
  ) -> ::flatbuffers::WIPOffset<FBResult<'bldr>> {
    let mut builder = FBResultBuilder::new(_fbb);
    if let Some(x) = args.table { builder.add_table(x); }
    if let Some(x) = args.routes { builder.add_routes(x); }
    if let Some(x) = args.waypoints { builder.add_waypoints(x); }
    if let Some(x) = args.data_version { builder.add_data_version(x); }
    if let Some(x) = args.code { builder.add_code(x); }
    builder.add_error(args.error);
    builder.finish()
  }


  #[inline]
  pub fn error(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(FBResult::VT_ERROR, Some(false)).unwrap()}
  }
  #[inline]
  pub fn code(&self) -> Option<Error<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<Error>>(FBResult::VT_CODE, None)}
  }
  #[inline]
  pub fn data_version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(FBResult::VT_DATA_VERSION, None)}
  }
  #[inline]
  pub fn waypoints(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Waypoint<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Waypoint>>>>(FBResult::VT_WAYPOINTS, None)}
  }
  #[inline]
  pub fn routes(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<RouteObject<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<RouteObject>>>>(FBResult::VT_ROUTES, None)}
  }
  #[inline]
  pub fn table(&self) -> Option<TableResult<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<TableResult>>(FBResult::VT_TABLE, None)}
  }
}

impl ::flatbuffers::Verifiable for FBResult<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<bool>("error", Self::VT_ERROR, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<Error>>("code", Self::VT_CODE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("data_version", Self::VT_DATA_VERSION, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Waypoint>>>>("waypoints", Self::VT_WAYPOINTS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<RouteObject>>>>("routes", Self::VT_ROUTES, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<TableResult>>("table", Self::VT_TABLE, false)?
     .finish();
    Ok(())
  }
}
pub struct FBResultArgs<'a> {
    pub error: bool,
    pub code: Option<::flatbuffers::WIPOffset<Error<'a>>>,
    pub data_version: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub waypoints: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Waypoint<'a>>>>>,
    pub routes: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<RouteObject<'a>>>>>,
    pub table: Option<::flatbuffers::WIPOffset<TableResult<'a>>>,
}
impl<'a> Default for FBResultArgs<'a> {
  #[inline]
  fn default() -> Self {
    FBResultArgs {
      error: false,
      code: None,
      data_version: None,
      waypoints: None,
      routes: None,
      table: None,
    }
  }
}

pub struct FBResultBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> FBResultBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_error(&mut self, error: bool) {
    self.fbb_.push_slot::<bool>(FBResult::VT_ERROR, error, false);
  }
  #[inline]
  pub fn add_code(&mut self, code: ::flatbuffers::WIPOffset<Error<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<Error>>(FBResult::VT_CODE, code);
  }
  #[inline]
  pub fn add_data_version(&mut self, data_version: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(FBResult::VT_DATA_VERSION, data_version);
  }
  #[inline]
  pub fn add_waypoints(&mut self, waypoints: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<Waypoint<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(FBResult::VT_WAYPOINTS, waypoints);
  }
  #[inline]
  pub fn add_routes(&mut self, routes: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<RouteObject<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(FBResult::VT_ROUTES, routes);
  }
  #[inline]
  pub fn add_table(&mut self, table: ::flatbuffers::WIPOffset<TableResult<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<TableResult>>(FBResult::VT_TABLE, table);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> FBResultBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FBResultBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<FBResult<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for FBResult<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("FBResult");
      ds.field("error", &self.error());
      ds.field("code", &self.code());
      ds.field("data_version", &self.data_version());
      ds.field("waypoints", &self.waypoints());
      ds.field("routes", &self.routes());
      ds.field("table", &self.table());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `FBResult`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_fbresult_unchecked`.
pub fn root_as_fbresult(buf: &[u8]) -> Result<FBResult<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root::<FBResult>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `FBResult` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_fbresult_unchecked`.
pub fn size_prefixed_root_as_fbresult(buf: &[u8]) -> Result<FBResult<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root::<FBResult>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `FBResult` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_fbresult_unchecked`.
pub fn root_as_fbresult_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FBResult<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root_with_opts::<FBResult<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `FBResult` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_fbresult_unchecked`.
pub fn size_prefixed_root_as_fbresult_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FBResult<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root_with_opts::<FBResult<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a FBResult and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `FBResult`.
pub unsafe fn root_as_fbresult_unchecked(buf: &[u8]) -> FBResult<'_> {
  unsafe { ::flatbuffers::root_unchecked::<FBResult>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed FBResult and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `FBResult`.
pub unsafe fn size_prefixed_root_as_fbresult_unchecked(buf: &[u8]) -> FBResult<'_> {
  unsafe { ::flatbuffers::size_prefixed_root_unchecked::<FBResult>(buf) }
}
#[inline]
pub fn finish_fbresult_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(
    fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
    root: ::flatbuffers::WIPOffset<FBResult<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_fbresult_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>, root: ::flatbuffers::WIPOffset<FBResult<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod fbresult
}  // pub mod api
}  // pub mod engine
}  // pub mod osrm

